// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `CreateBison` operation.
/// Each variant represents an error that can occur for the `CreateBison` operation.
#[derive(std::fmt::Debug)]
pub enum CreateBisonError {
    /// The server response for authorization failure.
    AccessDeniedException(crate::error::AccessDeniedException),
    /// The server cannot process the request due to an apparent client error.
    BadRequestException(crate::error::BadRequestException),
    /// The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    /// The server response when an unexpected error occurred while processing request.
    InternalFailureException(crate::error::InternalFailureException),
    /// The server response when the requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.
    NotAcceptableException(crate::error::NotAcceptableException),
    /// The server either does not recognize the request method, or it lacks the ability to fulfil the request.
    NotImplementedException(crate::error::NotImplementedException),
    /// The server response for the request too large error.
    RequestTooLargeException(crate::error::RequestTooLargeException),
    /// The server could not process the request because of conflict in the current state of the resource.
    ResourceConflictException(crate::error::ResourceConflictException),
    /// The server response when the specified resource cannot be found after an API request passes authentication and authorization.
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// The server response when attempting to serialize the request.
    SerializationException(crate::error::SerializationException),
    /// The server cannot handle the request due to technical reasons.
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// The server response when the operation specified could not be found.
    UnknownOperationException(crate::error::UnknownOperationException),
    /// The server response when a payload is of an unsupported media type.
    UnsupportedMediaTypeException(crate::error::UnsupportedMediaTypeException),
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl std::fmt::Display for CreateBisonError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            CreateBisonError::AccessDeniedException(_inner) => _inner.fmt(f),
            CreateBisonError::BadRequestException(_inner) => _inner.fmt(f),
            CreateBisonError::GatewayTimeoutException(_inner) => _inner.fmt(f),
            CreateBisonError::InternalFailureException(_inner) => _inner.fmt(f),
            CreateBisonError::NotAcceptableException(_inner) => _inner.fmt(f),
            CreateBisonError::NotImplementedException(_inner) => _inner.fmt(f),
            CreateBisonError::RequestTooLargeException(_inner) => _inner.fmt(f),
            CreateBisonError::ResourceConflictException(_inner) => _inner.fmt(f),
            CreateBisonError::ResourceNotFoundException(_inner) => _inner.fmt(f),
            CreateBisonError::SerializationException(_inner) => _inner.fmt(f),
            CreateBisonError::ServiceUnavailableException(_inner) => _inner.fmt(f),
            CreateBisonError::UnknownOperationException(_inner) => _inner.fmt(f),
            CreateBisonError::UnsupportedMediaTypeException(_inner) => _inner.fmt(f),
            CreateBisonError::ValidationException(_inner) => _inner.fmt(f),
        }
    }
}
impl CreateBisonError {
    /// Returns `true` if the error kind is `CreateBisonError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self, CreateBisonError::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self, CreateBisonError::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::GatewayTimeoutException`.
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self, CreateBisonError::GatewayTimeoutException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self, CreateBisonError::InternalFailureException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::NotAcceptableException`.
    pub fn is_not_acceptable_exception(&self) -> bool {
        matches!(&self, CreateBisonError::NotAcceptableException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::NotImplementedException`.
    pub fn is_not_implemented_exception(&self) -> bool {
        matches!(&self, CreateBisonError::NotImplementedException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::RequestTooLargeException`.
    pub fn is_request_too_large_exception(&self) -> bool {
        matches!(&self, CreateBisonError::RequestTooLargeException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::ResourceConflictException`.
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(&self, CreateBisonError::ResourceConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self, CreateBisonError::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::SerializationException`.
    pub fn is_serialization_exception(&self) -> bool {
        matches!(&self, CreateBisonError::SerializationException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self, CreateBisonError::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::UnknownOperationException`.
    pub fn is_unknown_operation_exception(&self) -> bool {
        matches!(&self, CreateBisonError::UnknownOperationException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::UnsupportedMediaTypeException`.
    pub fn is_unsupported_media_type_exception(&self) -> bool {
        matches!(&self, CreateBisonError::UnsupportedMediaTypeException(_))
    }
    /// Returns `true` if the error kind is `CreateBisonError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, CreateBisonError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            CreateBisonError::AccessDeniedException(_inner) => _inner.name(),
            CreateBisonError::BadRequestException(_inner) => _inner.name(),
            CreateBisonError::GatewayTimeoutException(_inner) => _inner.name(),
            CreateBisonError::InternalFailureException(_inner) => _inner.name(),
            CreateBisonError::NotAcceptableException(_inner) => _inner.name(),
            CreateBisonError::NotImplementedException(_inner) => _inner.name(),
            CreateBisonError::RequestTooLargeException(_inner) => _inner.name(),
            CreateBisonError::ResourceConflictException(_inner) => _inner.name(),
            CreateBisonError::ResourceNotFoundException(_inner) => _inner.name(),
            CreateBisonError::SerializationException(_inner) => _inner.name(),
            CreateBisonError::ServiceUnavailableException(_inner) => _inner.name(),
            CreateBisonError::UnknownOperationException(_inner) => _inner.name(),
            CreateBisonError::UnsupportedMediaTypeException(_inner) => _inner.name(),
            CreateBisonError::ValidationException(_inner) => _inner.name(),
        }
    }
}
impl std::error::Error for CreateBisonError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self {
            CreateBisonError::AccessDeniedException(_inner) => Some(_inner),
            CreateBisonError::BadRequestException(_inner) => Some(_inner),
            CreateBisonError::GatewayTimeoutException(_inner) => Some(_inner),
            CreateBisonError::InternalFailureException(_inner) => Some(_inner),
            CreateBisonError::NotAcceptableException(_inner) => Some(_inner),
            CreateBisonError::NotImplementedException(_inner) => Some(_inner),
            CreateBisonError::RequestTooLargeException(_inner) => Some(_inner),
            CreateBisonError::ResourceConflictException(_inner) => Some(_inner),
            CreateBisonError::ResourceNotFoundException(_inner) => Some(_inner),
            CreateBisonError::SerializationException(_inner) => Some(_inner),
            CreateBisonError::ServiceUnavailableException(_inner) => Some(_inner),
            CreateBisonError::UnknownOperationException(_inner) => Some(_inner),
            CreateBisonError::UnsupportedMediaTypeException(_inner) => Some(_inner),
            CreateBisonError::ValidationException(_inner) => Some(_inner),
        }
    }
}
impl From<crate::error::AccessDeniedException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::AccessDeniedException) -> crate::error::CreateBisonError {
        Self::AccessDeniedException(variant)
    }
}
impl From<crate::error::BadRequestException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::BadRequestException) -> crate::error::CreateBisonError {
        Self::BadRequestException(variant)
    }
}
impl From<crate::error::GatewayTimeoutException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::GatewayTimeoutException) -> crate::error::CreateBisonError {
        Self::GatewayTimeoutException(variant)
    }
}
impl From<crate::error::InternalFailureException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::InternalFailureException) -> crate::error::CreateBisonError {
        Self::InternalFailureException(variant)
    }
}
impl From<crate::error::NotAcceptableException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::NotAcceptableException) -> crate::error::CreateBisonError {
        Self::NotAcceptableException(variant)
    }
}
impl From<crate::error::NotImplementedException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::NotImplementedException) -> crate::error::CreateBisonError {
        Self::NotImplementedException(variant)
    }
}
impl From<crate::error::RequestTooLargeException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::RequestTooLargeException) -> crate::error::CreateBisonError {
        Self::RequestTooLargeException(variant)
    }
}
impl From<crate::error::ResourceConflictException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::ResourceConflictException) -> crate::error::CreateBisonError {
        Self::ResourceConflictException(variant)
    }
}
impl From<crate::error::ResourceNotFoundException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::ResourceNotFoundException) -> crate::error::CreateBisonError {
        Self::ResourceNotFoundException(variant)
    }
}
impl From<crate::error::SerializationException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::SerializationException) -> crate::error::CreateBisonError {
        Self::SerializationException(variant)
    }
}
impl From<crate::error::ServiceUnavailableException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::ServiceUnavailableException) -> crate::error::CreateBisonError {
        Self::ServiceUnavailableException(variant)
    }
}
impl From<crate::error::UnknownOperationException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::UnknownOperationException) -> crate::error::CreateBisonError {
        Self::UnknownOperationException(variant)
    }
}
impl From<crate::error::UnsupportedMediaTypeException> for crate::error::CreateBisonError {
    fn from(
        variant: crate::error::UnsupportedMediaTypeException,
    ) -> crate::error::CreateBisonError {
        Self::UnsupportedMediaTypeException(variant)
    }
}
impl From<crate::error::ValidationException> for crate::error::CreateBisonError {
    fn from(variant: crate::error::ValidationException) -> crate::error::CreateBisonError {
        Self::ValidationException(variant)
    }
}

/// Error type for the `ListBison` operation.
/// Each variant represents an error that can occur for the `ListBison` operation.
#[derive(std::fmt::Debug)]
pub enum ListBisonError {
    /// The server response for authorization failure.
    AccessDeniedException(crate::error::AccessDeniedException),
    /// The server cannot process the request due to an apparent client error.
    BadRequestException(crate::error::BadRequestException),
    /// The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.
    GatewayTimeoutException(crate::error::GatewayTimeoutException),
    /// The server response when an unexpected error occurred while processing request.
    InternalFailureException(crate::error::InternalFailureException),
    /// The server response when the requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.
    NotAcceptableException(crate::error::NotAcceptableException),
    /// The server either does not recognize the request method, or it lacks the ability to fulfil the request.
    NotImplementedException(crate::error::NotImplementedException),
    /// The server response for the request too large error.
    RequestTooLargeException(crate::error::RequestTooLargeException),
    /// The server could not process the request because of conflict in the current state of the resource.
    ResourceConflictException(crate::error::ResourceConflictException),
    /// The server response when the specified resource cannot be found after an API request passes authentication and authorization.
    ResourceNotFoundException(crate::error::ResourceNotFoundException),
    /// The server response when attempting to serialize the request.
    SerializationException(crate::error::SerializationException),
    /// The server cannot handle the request due to technical reasons.
    ServiceUnavailableException(crate::error::ServiceUnavailableException),
    /// The server response when the operation specified could not be found.
    UnknownOperationException(crate::error::UnknownOperationException),
    /// The server response when a payload is of an unsupported media type.
    UnsupportedMediaTypeException(crate::error::UnsupportedMediaTypeException),
    /// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
    ValidationException(crate::error::ValidationException),
}
impl std::fmt::Display for ListBisonError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            ListBisonError::AccessDeniedException(_inner) => _inner.fmt(f),
            ListBisonError::BadRequestException(_inner) => _inner.fmt(f),
            ListBisonError::GatewayTimeoutException(_inner) => _inner.fmt(f),
            ListBisonError::InternalFailureException(_inner) => _inner.fmt(f),
            ListBisonError::NotAcceptableException(_inner) => _inner.fmt(f),
            ListBisonError::NotImplementedException(_inner) => _inner.fmt(f),
            ListBisonError::RequestTooLargeException(_inner) => _inner.fmt(f),
            ListBisonError::ResourceConflictException(_inner) => _inner.fmt(f),
            ListBisonError::ResourceNotFoundException(_inner) => _inner.fmt(f),
            ListBisonError::SerializationException(_inner) => _inner.fmt(f),
            ListBisonError::ServiceUnavailableException(_inner) => _inner.fmt(f),
            ListBisonError::UnknownOperationException(_inner) => _inner.fmt(f),
            ListBisonError::UnsupportedMediaTypeException(_inner) => _inner.fmt(f),
            ListBisonError::ValidationException(_inner) => _inner.fmt(f),
        }
    }
}
impl ListBisonError {
    /// Returns `true` if the error kind is `ListBisonError::AccessDeniedException`.
    pub fn is_access_denied_exception(&self) -> bool {
        matches!(&self, ListBisonError::AccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::BadRequestException`.
    pub fn is_bad_request_exception(&self) -> bool {
        matches!(&self, ListBisonError::BadRequestException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::GatewayTimeoutException`.
    pub fn is_gateway_timeout_exception(&self) -> bool {
        matches!(&self, ListBisonError::GatewayTimeoutException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::InternalFailureException`.
    pub fn is_internal_failure_exception(&self) -> bool {
        matches!(&self, ListBisonError::InternalFailureException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::NotAcceptableException`.
    pub fn is_not_acceptable_exception(&self) -> bool {
        matches!(&self, ListBisonError::NotAcceptableException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::NotImplementedException`.
    pub fn is_not_implemented_exception(&self) -> bool {
        matches!(&self, ListBisonError::NotImplementedException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::RequestTooLargeException`.
    pub fn is_request_too_large_exception(&self) -> bool {
        matches!(&self, ListBisonError::RequestTooLargeException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::ResourceConflictException`.
    pub fn is_resource_conflict_exception(&self) -> bool {
        matches!(&self, ListBisonError::ResourceConflictException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::ResourceNotFoundException`.
    pub fn is_resource_not_found_exception(&self) -> bool {
        matches!(&self, ListBisonError::ResourceNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::SerializationException`.
    pub fn is_serialization_exception(&self) -> bool {
        matches!(&self, ListBisonError::SerializationException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::ServiceUnavailableException`.
    pub fn is_service_unavailable_exception(&self) -> bool {
        matches!(&self, ListBisonError::ServiceUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::UnknownOperationException`.
    pub fn is_unknown_operation_exception(&self) -> bool {
        matches!(&self, ListBisonError::UnknownOperationException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::UnsupportedMediaTypeException`.
    pub fn is_unsupported_media_type_exception(&self) -> bool {
        matches!(&self, ListBisonError::UnsupportedMediaTypeException(_))
    }
    /// Returns `true` if the error kind is `ListBisonError::ValidationException`.
    pub fn is_validation_exception(&self) -> bool {
        matches!(&self, ListBisonError::ValidationException(_))
    }
    /// Returns the error name string by matching the correct variant.
    pub fn name(&self) -> &'static str {
        match &self {
            ListBisonError::AccessDeniedException(_inner) => _inner.name(),
            ListBisonError::BadRequestException(_inner) => _inner.name(),
            ListBisonError::GatewayTimeoutException(_inner) => _inner.name(),
            ListBisonError::InternalFailureException(_inner) => _inner.name(),
            ListBisonError::NotAcceptableException(_inner) => _inner.name(),
            ListBisonError::NotImplementedException(_inner) => _inner.name(),
            ListBisonError::RequestTooLargeException(_inner) => _inner.name(),
            ListBisonError::ResourceConflictException(_inner) => _inner.name(),
            ListBisonError::ResourceNotFoundException(_inner) => _inner.name(),
            ListBisonError::SerializationException(_inner) => _inner.name(),
            ListBisonError::ServiceUnavailableException(_inner) => _inner.name(),
            ListBisonError::UnknownOperationException(_inner) => _inner.name(),
            ListBisonError::UnsupportedMediaTypeException(_inner) => _inner.name(),
            ListBisonError::ValidationException(_inner) => _inner.name(),
        }
    }
}
impl std::error::Error for ListBisonError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self {
            ListBisonError::AccessDeniedException(_inner) => Some(_inner),
            ListBisonError::BadRequestException(_inner) => Some(_inner),
            ListBisonError::GatewayTimeoutException(_inner) => Some(_inner),
            ListBisonError::InternalFailureException(_inner) => Some(_inner),
            ListBisonError::NotAcceptableException(_inner) => Some(_inner),
            ListBisonError::NotImplementedException(_inner) => Some(_inner),
            ListBisonError::RequestTooLargeException(_inner) => Some(_inner),
            ListBisonError::ResourceConflictException(_inner) => Some(_inner),
            ListBisonError::ResourceNotFoundException(_inner) => Some(_inner),
            ListBisonError::SerializationException(_inner) => Some(_inner),
            ListBisonError::ServiceUnavailableException(_inner) => Some(_inner),
            ListBisonError::UnknownOperationException(_inner) => Some(_inner),
            ListBisonError::UnsupportedMediaTypeException(_inner) => Some(_inner),
            ListBisonError::ValidationException(_inner) => Some(_inner),
        }
    }
}
impl From<crate::error::AccessDeniedException> for crate::error::ListBisonError {
    fn from(variant: crate::error::AccessDeniedException) -> crate::error::ListBisonError {
        Self::AccessDeniedException(variant)
    }
}
impl From<crate::error::BadRequestException> for crate::error::ListBisonError {
    fn from(variant: crate::error::BadRequestException) -> crate::error::ListBisonError {
        Self::BadRequestException(variant)
    }
}
impl From<crate::error::GatewayTimeoutException> for crate::error::ListBisonError {
    fn from(variant: crate::error::GatewayTimeoutException) -> crate::error::ListBisonError {
        Self::GatewayTimeoutException(variant)
    }
}
impl From<crate::error::InternalFailureException> for crate::error::ListBisonError {
    fn from(variant: crate::error::InternalFailureException) -> crate::error::ListBisonError {
        Self::InternalFailureException(variant)
    }
}
impl From<crate::error::NotAcceptableException> for crate::error::ListBisonError {
    fn from(variant: crate::error::NotAcceptableException) -> crate::error::ListBisonError {
        Self::NotAcceptableException(variant)
    }
}
impl From<crate::error::NotImplementedException> for crate::error::ListBisonError {
    fn from(variant: crate::error::NotImplementedException) -> crate::error::ListBisonError {
        Self::NotImplementedException(variant)
    }
}
impl From<crate::error::RequestTooLargeException> for crate::error::ListBisonError {
    fn from(variant: crate::error::RequestTooLargeException) -> crate::error::ListBisonError {
        Self::RequestTooLargeException(variant)
    }
}
impl From<crate::error::ResourceConflictException> for crate::error::ListBisonError {
    fn from(variant: crate::error::ResourceConflictException) -> crate::error::ListBisonError {
        Self::ResourceConflictException(variant)
    }
}
impl From<crate::error::ResourceNotFoundException> for crate::error::ListBisonError {
    fn from(variant: crate::error::ResourceNotFoundException) -> crate::error::ListBisonError {
        Self::ResourceNotFoundException(variant)
    }
}
impl From<crate::error::SerializationException> for crate::error::ListBisonError {
    fn from(variant: crate::error::SerializationException) -> crate::error::ListBisonError {
        Self::SerializationException(variant)
    }
}
impl From<crate::error::ServiceUnavailableException> for crate::error::ListBisonError {
    fn from(variant: crate::error::ServiceUnavailableException) -> crate::error::ListBisonError {
        Self::ServiceUnavailableException(variant)
    }
}
impl From<crate::error::UnknownOperationException> for crate::error::ListBisonError {
    fn from(variant: crate::error::UnknownOperationException) -> crate::error::ListBisonError {
        Self::UnknownOperationException(variant)
    }
}
impl From<crate::error::UnsupportedMediaTypeException> for crate::error::ListBisonError {
    fn from(variant: crate::error::UnsupportedMediaTypeException) -> crate::error::ListBisonError {
        Self::UnsupportedMediaTypeException(variant)
    }
}
impl From<crate::error::ValidationException> for crate::error::ListBisonError {
    fn from(variant: crate::error::ValidationException) -> crate::error::ListBisonError {
        Self::ValidationException(variant)
    }
}

/// A standard error for input validation failures. This should be thrown by services when a member of the input structure falls outside of the modeled or documented constraints.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ValidationException {
    /// A summary of the validation failure.
    pub message: std::string::String,
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub field_list: std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>,
}
impl ValidationException {
    /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
    pub fn field_list(&self) -> std::option::Option<&[crate::model::ValidationExceptionField]> {
        self.field_list.as_deref()
    }
}
impl std::fmt::Debug for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ValidationException");
        formatter.field("message", &self.message);
        formatter.field("field_list", &self.field_list);
        formatter.finish()
    }
}
impl ValidationException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ValidationException"
    }
}
impl std::fmt::Display for ValidationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ValidationException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for ValidationException {}
/// See [`ValidationException`](crate::error::ValidationException)
pub mod validation_exception {
    /// A builder for [`ValidationException`](crate::error::ValidationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) field_list:
            std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>,
    }
    impl Builder {
        /// A summary of the validation failure.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// A summary of the validation failure.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Appends an item to `field_list`.
        ///
        /// To override the contents of this collection use [`set_field_list`](Self::set_field_list).
        ///
        /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
        pub fn field_list(mut self, input: crate::model::ValidationExceptionField) -> Self {
            let mut v = self.field_list.unwrap_or_default();
            v.push(input);
            self.field_list = Some(v);
            self
        }
        /// A list of specific failures encountered while validating the input. A member can appear in this list more than once if it failed to satisfy multiple constraints.
        pub fn set_field_list(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ValidationExceptionField>>,
        ) -> Self {
            self.field_list = input;
            self
        }
        /// Consumes the builder and constructs a [`ValidationException`](crate::error::ValidationException)
        pub fn build(self) -> crate::error::ValidationException {
            crate::error::ValidationException {
                message: self.message.unwrap_or_default(),
                field_list: self.field_list,
            }
        }
    }
}
impl ValidationException {
    /// Creates a new builder-style object to manufacture [`ValidationException`](crate::error::ValidationException)
    pub fn builder() -> crate::error::validation_exception::Builder {
        crate::error::validation_exception::Builder::default()
    }
}

/// The server response when a payload is of an unsupported media type.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnsupportedMediaTypeException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl UnsupportedMediaTypeException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for UnsupportedMediaTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnsupportedMediaTypeException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl UnsupportedMediaTypeException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "UnsupportedMediaTypeException"
    }
}
impl std::fmt::Display for UnsupportedMediaTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnsupportedMediaTypeException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for UnsupportedMediaTypeException {}
/// See [`UnsupportedMediaTypeException`](crate::error::UnsupportedMediaTypeException)
pub mod unsupported_media_type_exception {
    /// A builder for [`UnsupportedMediaTypeException`](crate::error::UnsupportedMediaTypeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`UnsupportedMediaTypeException`](crate::error::UnsupportedMediaTypeException)
        pub fn build(self) -> crate::error::UnsupportedMediaTypeException {
            crate::error::UnsupportedMediaTypeException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl UnsupportedMediaTypeException {
    /// Creates a new builder-style object to manufacture [`UnsupportedMediaTypeException`](crate::error::UnsupportedMediaTypeException)
    pub fn builder() -> crate::error::unsupported_media_type_exception::Builder {
        crate::error::unsupported_media_type_exception::Builder::default()
    }
}

/// The server response when the operation specified could not be found.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct UnknownOperationException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl UnknownOperationException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for UnknownOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("UnknownOperationException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl UnknownOperationException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "UnknownOperationException"
    }
}
impl std::fmt::Display for UnknownOperationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "UnknownOperationException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for UnknownOperationException {}
/// See [`UnknownOperationException`](crate::error::UnknownOperationException)
pub mod unknown_operation_exception {
    /// A builder for [`UnknownOperationException`](crate::error::UnknownOperationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`UnknownOperationException`](crate::error::UnknownOperationException)
        pub fn build(self) -> crate::error::UnknownOperationException {
            crate::error::UnknownOperationException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl UnknownOperationException {
    /// Creates a new builder-style object to manufacture [`UnknownOperationException`](crate::error::UnknownOperationException)
    pub fn builder() -> crate::error::unknown_operation_exception::Builder {
        crate::error::unknown_operation_exception::Builder::default()
    }
}

/// The server cannot handle the request due to technical reasons.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ServiceUnavailableException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl ServiceUnavailableException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ServiceUnavailableException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl ServiceUnavailableException {
    /// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
    pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
        aws_smithy_types::retry::ErrorKind::ServerError
    }
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ServiceUnavailableException"
    }
}
impl std::fmt::Display for ServiceUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ServiceUnavailableException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for ServiceUnavailableException {}
/// See [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
pub mod service_unavailable_exception {
    /// A builder for [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
        pub fn build(self) -> crate::error::ServiceUnavailableException {
            crate::error::ServiceUnavailableException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl ServiceUnavailableException {
    /// Creates a new builder-style object to manufacture [`ServiceUnavailableException`](crate::error::ServiceUnavailableException)
    pub fn builder() -> crate::error::service_unavailable_exception::Builder {
        crate::error::service_unavailable_exception::Builder::default()
    }
}

/// The server response when attempting to serialize the request.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SerializationException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl SerializationException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for SerializationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SerializationException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl SerializationException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "SerializationException"
    }
}
impl std::fmt::Display for SerializationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SerializationException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for SerializationException {}
/// See [`SerializationException`](crate::error::SerializationException)
pub mod serialization_exception {
    /// A builder for [`SerializationException`](crate::error::SerializationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`SerializationException`](crate::error::SerializationException)
        pub fn build(self) -> crate::error::SerializationException {
            crate::error::SerializationException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl SerializationException {
    /// Creates a new builder-style object to manufacture [`SerializationException`](crate::error::SerializationException)
    pub fn builder() -> crate::error::serialization_exception::Builder {
        crate::error::serialization_exception::Builder::default()
    }
}

/// The server response when the specified resource cannot be found after an API request passes authentication and authorization.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceNotFoundException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl ResourceNotFoundException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceNotFoundException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl ResourceNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ResourceNotFoundException"
    }
}
impl std::fmt::Display for ResourceNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceNotFoundException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for ResourceNotFoundException {}
/// See [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
pub mod resource_not_found_exception {
    /// A builder for [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
        pub fn build(self) -> crate::error::ResourceNotFoundException {
            crate::error::ResourceNotFoundException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl ResourceNotFoundException {
    /// Creates a new builder-style object to manufacture [`ResourceNotFoundException`](crate::error::ResourceNotFoundException)
    pub fn builder() -> crate::error::resource_not_found_exception::Builder {
        crate::error::resource_not_found_exception::Builder::default()
    }
}

/// The server could not process the request because of conflict in the current state of the resource.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceConflictException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl ResourceConflictException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for ResourceConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceConflictException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl ResourceConflictException {
    /// Returns `Some(ErrorKind)` if the error is retryable. Otherwise, returns `None`.
    pub fn retryable_error_kind(&self) -> aws_smithy_types::retry::ErrorKind {
        aws_smithy_types::retry::ErrorKind::ClientError
    }
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "ResourceConflictException"
    }
}
impl std::fmt::Display for ResourceConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceConflictException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for ResourceConflictException {}
/// See [`ResourceConflictException`](crate::error::ResourceConflictException)
pub mod resource_conflict_exception {
    /// A builder for [`ResourceConflictException`](crate::error::ResourceConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceConflictException`](crate::error::ResourceConflictException)
        pub fn build(self) -> crate::error::ResourceConflictException {
            crate::error::ResourceConflictException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl ResourceConflictException {
    /// Creates a new builder-style object to manufacture [`ResourceConflictException`](crate::error::ResourceConflictException)
    pub fn builder() -> crate::error::resource_conflict_exception::Builder {
        crate::error::resource_conflict_exception::Builder::default()
    }
}

/// The server response for the request too large error.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RequestTooLargeException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl RequestTooLargeException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for RequestTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RequestTooLargeException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl RequestTooLargeException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "RequestTooLargeException"
    }
}
impl std::fmt::Display for RequestTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RequestTooLargeException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for RequestTooLargeException {}
/// See [`RequestTooLargeException`](crate::error::RequestTooLargeException)
pub mod request_too_large_exception {
    /// A builder for [`RequestTooLargeException`](crate::error::RequestTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`RequestTooLargeException`](crate::error::RequestTooLargeException)
        pub fn build(self) -> crate::error::RequestTooLargeException {
            crate::error::RequestTooLargeException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl RequestTooLargeException {
    /// Creates a new builder-style object to manufacture [`RequestTooLargeException`](crate::error::RequestTooLargeException)
    pub fn builder() -> crate::error::request_too_large_exception::Builder {
        crate::error::request_too_large_exception::Builder::default()
    }
}

/// The server either does not recognize the request method, or it lacks the ability to fulfil the request.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotImplementedException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl NotImplementedException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for NotImplementedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotImplementedException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl NotImplementedException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "NotImplementedException"
    }
}
impl std::fmt::Display for NotImplementedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotImplementedException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for NotImplementedException {}
/// See [`NotImplementedException`](crate::error::NotImplementedException)
pub mod not_implemented_exception {
    /// A builder for [`NotImplementedException`](crate::error::NotImplementedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`NotImplementedException`](crate::error::NotImplementedException)
        pub fn build(self) -> crate::error::NotImplementedException {
            crate::error::NotImplementedException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl NotImplementedException {
    /// Creates a new builder-style object to manufacture [`NotImplementedException`](crate::error::NotImplementedException)
    pub fn builder() -> crate::error::not_implemented_exception::Builder {
        crate::error::not_implemented_exception::Builder::default()
    }
}

/// The server response when the requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NotAcceptableException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl NotAcceptableException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for NotAcceptableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NotAcceptableException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl NotAcceptableException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "NotAcceptableException"
    }
}
impl std::fmt::Display for NotAcceptableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NotAcceptableException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for NotAcceptableException {}
/// See [`NotAcceptableException`](crate::error::NotAcceptableException)
pub mod not_acceptable_exception {
    /// A builder for [`NotAcceptableException`](crate::error::NotAcceptableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`NotAcceptableException`](crate::error::NotAcceptableException)
        pub fn build(self) -> crate::error::NotAcceptableException {
            crate::error::NotAcceptableException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl NotAcceptableException {
    /// Creates a new builder-style object to manufacture [`NotAcceptableException`](crate::error::NotAcceptableException)
    pub fn builder() -> crate::error::not_acceptable_exception::Builder {
        crate::error::not_acceptable_exception::Builder::default()
    }
}

/// The server response when an unexpected error occurred while processing request.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InternalFailureException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl InternalFailureException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InternalFailureException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl InternalFailureException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "InternalFailureException"
    }
}
impl std::fmt::Display for InternalFailureException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InternalFailureException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for InternalFailureException {}
/// See [`InternalFailureException`](crate::error::InternalFailureException)
pub mod internal_failure_exception {
    /// A builder for [`InternalFailureException`](crate::error::InternalFailureException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`InternalFailureException`](crate::error::InternalFailureException)
        pub fn build(self) -> crate::error::InternalFailureException {
            crate::error::InternalFailureException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl InternalFailureException {
    /// Creates a new builder-style object to manufacture [`InternalFailureException`](crate::error::InternalFailureException)
    pub fn builder() -> crate::error::internal_failure_exception::Builder {
        crate::error::internal_failure_exception::Builder::default()
    }
}

/// The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct GatewayTimeoutException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl GatewayTimeoutException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for GatewayTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("GatewayTimeoutException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl GatewayTimeoutException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "GatewayTimeoutException"
    }
}
impl std::fmt::Display for GatewayTimeoutException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "GatewayTimeoutException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for GatewayTimeoutException {}
/// See [`GatewayTimeoutException`](crate::error::GatewayTimeoutException)
pub mod gateway_timeout_exception {
    /// A builder for [`GatewayTimeoutException`](crate::error::GatewayTimeoutException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`GatewayTimeoutException`](crate::error::GatewayTimeoutException)
        pub fn build(self) -> crate::error::GatewayTimeoutException {
            crate::error::GatewayTimeoutException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl GatewayTimeoutException {
    /// Creates a new builder-style object to manufacture [`GatewayTimeoutException`](crate::error::GatewayTimeoutException)
    pub fn builder() -> crate::error::gateway_timeout_exception::Builder {
        crate::error::gateway_timeout_exception::Builder::default()
    }
}

/// The server cannot process the request due to an apparent client error.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BadRequestException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl BadRequestException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BadRequestException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl BadRequestException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "BadRequestException"
    }
}
impl std::fmt::Display for BadRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BadRequestException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for BadRequestException {}
/// See [`BadRequestException`](crate::error::BadRequestException)
pub mod bad_request_exception {
    /// A builder for [`BadRequestException`](crate::error::BadRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`BadRequestException`](crate::error::BadRequestException)
        pub fn build(self) -> crate::error::BadRequestException {
            crate::error::BadRequestException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl BadRequestException {
    /// Creates a new builder-style object to manufacture [`BadRequestException`](crate::error::BadRequestException)
    pub fn builder() -> crate::error::bad_request_exception::Builder {
        crate::error::bad_request_exception::Builder::default()
    }
}

/// The server response for authorization failure.
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AccessDeniedException {
    /// Human readable exception message.
    pub message: std::string::String,
    /// Classification of the exception type.
    pub code: std::option::Option<std::string::String>,
}
impl AccessDeniedException {
    /// Classification of the exception type.
    pub fn code(&self) -> std::option::Option<&str> {
        self.code.as_deref()
    }
}
impl std::fmt::Debug for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AccessDeniedException");
        formatter.field("message", &self.message);
        formatter.field("code", &self.code);
        formatter.finish()
    }
}
impl AccessDeniedException {
    /// Returns the error message.
    pub fn message(&self) -> &str {
        self.message.as_ref()
    }
    #[doc(hidden)]
    /// Returns the error name.
    pub fn name(&self) -> &'static str {
        "AccessDeniedException"
    }
}
impl std::fmt::Display for AccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AccessDeniedException")?;
        write!(f, ": {}", &self.message)?;
        Ok(())
    }
}
impl std::error::Error for AccessDeniedException {}
/// See [`AccessDeniedException`](crate::error::AccessDeniedException)
pub mod access_denied_exception {
    /// A builder for [`AccessDeniedException`](crate::error::AccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        pub(crate) code: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// Human readable exception message.
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// Human readable exception message.
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Classification of the exception type.
        pub fn code(mut self, input: impl Into<std::string::String>) -> Self {
            self.code = Some(input.into());
            self
        }
        /// Classification of the exception type.
        pub fn set_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.code = input;
            self
        }
        /// Consumes the builder and constructs a [`AccessDeniedException`](crate::error::AccessDeniedException)
        pub fn build(self) -> crate::error::AccessDeniedException {
            crate::error::AccessDeniedException {
                message: self.message.unwrap_or_default(),
                code: self.code,
            }
        }
    }
}
impl AccessDeniedException {
    /// Creates a new builder-style object to manufacture [`AccessDeniedException`](crate::error::AccessDeniedException)
    pub fn builder() -> crate::error::access_denied_exception::Builder {
        crate::error::access_denied_exception::Builder::default()
    }
}
